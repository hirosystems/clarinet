{
  "metadata": {
    "description": "",
    "execution_cost": {
      "read_count": 8,
      "read_length": 6,
      "runtime": 84581,
      "write_count": 13,
      "write_length": 1612
    },
    "fee": 750000,
    "kind": {
      "data": {
        "code": ";; The .subnet contract\n\n(define-constant CONTRACT_ADDRESS (as-contract tx-sender))\n\n;; Error codes\n(define-constant ERR_BLOCK_ALREADY_COMMITTED 1)\n(define-constant ERR_INVALID_MINER 2)\n(define-constant ERR_CONTRACT_CALL_FAILED 3)\n(define-constant ERR_TRANSFER_FAILED 4)\n(define-constant ERR_DISALLOWED_ASSET 5)\n(define-constant ERR_ASSET_ALREADY_ALLOWED 6)\n(define-constant ERR_MERKLE_ROOT_DOES_NOT_MATCH 7)\n(define-constant ERR_INVALID_MERKLE_ROOT 8)\n(define-constant ERR_WITHDRAWAL_ALREADY_PROCESSED 9)\n(define-constant ERR_VALIDATION_FAILED 10)\n;;; The value supplied for `target-chain-tip` does not match the current chain tip.\n(define-constant ERR_INVALID_CHAIN_TIP 11)\n;;; The contract was called before reaching this-chain height reaches 1.\n(define-constant ERR_CALLED_TOO_EARLY 12)\n(define-constant ERR_MINT_FAILED 13)\n(define-constant ERR_ATTEMPT_TO_TRANSFER_ZERO_AMOUNT 14)\n(define-constant ERR_IN_COMPUTATION 15)\n;; The contract does not own this NFT to withdraw it.\n(define-constant ERR_NFT_NOT_OWNED_BY_CONTRACT 16)\n(define-constant ERR_VALIDATION_LEAF_FAILED 30)\n\n;; Map from Stacks block height to block commit\n(define-map block-commits uint (buff 32))\n;; Map recording withdrawal roots\n(define-map withdrawal-roots-map (buff 32) bool)\n;; Map recording processed withdrawal leaves\n(define-map processed-withdrawal-leaves-map { withdrawal-leaf-hash: (buff 32), withdrawal-root-hash: (buff 32) } bool)\n\n;; principal that can commit blocks\n(define-data-var miner principal tx-sender)\n;; principal that can register contracts\n(define-data-var admin principal 'ST167FDXCJGS54J1T0J42VTX46G0QQQFRJGBK28RN)\n\n;; Map of allowed contracts for asset transfers - maps L1 contract principal to L2 contract principal\n(define-map allowed-contracts principal principal)\n\n;; Use trait declarations\n(use-trait nft-trait 'ST1NXBK3K5YYMD6FD41MVNP3JS1GABZ8TRVX023PT.nft-trait.nft-trait)\n(use-trait ft-trait 'ST1NXBK3K5YYMD6FD41MVNP3JS1GABZ8TRVX023PT.sip-010-trait-ft-standard.sip-010-trait)\n(use-trait mint-from-subnet-trait .subnet-traits-v1.mint-from-subnet-trait)\n\n;; Update the miner for this contract.\n(define-public (update-miner (new-miner principal))\n    (begin\n        (asserts! (is-eq tx-sender (var-get miner)) (err ERR_INVALID_MINER))\n        (ok (var-set miner new-miner))\n    )\n)\n\n;; Register a new FT contract to be supported by this subnet.\n(define-public (register-new-ft-contract (ft-contract <ft-trait>) (l2-contract principal))\n    (begin\n        ;; Verify that tx-sender is an authorized admin\n        (asserts! (is-admin tx-sender) (err ERR_INVALID_MINER))\n\n        ;; Set up the assets that the contract is allowed to transfer\n        (asserts! (map-insert allowed-contracts (contract-of ft-contract) l2-contract)\n                  (err ERR_ASSET_ALREADY_ALLOWED))\n\n        (print {\n            event: \"register-contract\",\n            asset-type: \"ft\",\n            l1-contract: (contract-of ft-contract),\n            l2-contract: l2-contract\n        })\n\n        (ok true)\n    )\n)\n\n;; Register a new NFT contract to be supported by this subnet.\n(define-public (register-new-nft-contract (nft-contract <nft-trait>) (l2-contract principal))\n    (begin\n        ;; Verify that tx-sender is an authorized admin\n        (asserts! (is-admin tx-sender) (err ERR_INVALID_MINER))\n\n        ;; Set up the assets that the contract is allowed to transfer\n        (asserts! (map-insert allowed-contracts (contract-of nft-contract) l2-contract)\n                  (err ERR_ASSET_ALREADY_ALLOWED))\n\n        (print {\n            event: \"register-contract\",\n            asset-type: \"nft\",\n            l1-contract: (contract-of nft-contract),\n            l2-contract: l2-contract\n        })\n\n        (ok true)\n    )\n)\n\n;; Helper function: returns a boolean indicating whether the given principal is a miner\n;; Returns bool\n(define-private (is-miner (miner-to-check principal))\n    (is-eq miner-to-check (var-get miner))\n)\n\n;; Helper function: returns a boolean indicating whether the given principal is an admin\n;; Returns bool\n(define-private (is-admin (addr-to-check principal))\n    (is-eq addr-to-check (var-get admin))\n)\n\n;; Helper function: determines whether the commit-block operation satisfies pre-conditions\n;; listed in `commit-block`.\n;; Returns response<bool, int>\n(define-private (can-commit-block? (commit-block-height uint)  (target-chain-tip (buff 32)))\n    (begin\n        ;; check no block has been committed at this height\n        (asserts! (is-none (map-get? block-commits commit-block-height)) (err ERR_BLOCK_ALREADY_COMMITTED))\n\n        ;; check that `target-chain-tip` matches the burn chain tip\n        (asserts! (is-eq\n            target-chain-tip\n            (unwrap! (get-block-info? id-header-hash (- block-height u1)) (err ERR_CALLED_TOO_EARLY)) )\n            (err ERR_INVALID_CHAIN_TIP))\n\n        ;; check that the tx sender is one of the miners\n        (asserts! (is-miner tx-sender) (err ERR_INVALID_MINER))\n\n        ;; check that the miner called this contract directly\n        (asserts! (is-miner contract-caller) (err ERR_INVALID_MINER))\n\n        (ok true)\n    )\n)\n\n;; Helper function: modifies the block-commits map with a new commit and prints related info\n;; Returns response<(buff 32), ?>\n(define-private (inner-commit-block (block (buff 32)) (commit-block-height uint) (withdrawal-root (buff 32)))\n    (begin\n        (map-set block-commits commit-block-height block)\n        (map-set withdrawal-roots-map withdrawal-root true)\n        (print {\n            event: \"block-commit\",\n            block-commit: block,\n            withdrawal-root: withdrawal-root,\n            block-height: commit-block-height\n        })\n        (ok block)\n    )\n)\n\n;; The subnet miner calls this function to commit a block at a particular height.\n;; `block` is the hash of the block being submitted.\n;; `target-chain-tip` is the `id-header-hash` of the burn block (i.e., block on\n;;    this chain) that the miner intends to build off.\n;;\n;; Fails if:\n;;  1) we have already committed at this block height\n;;  2) `target-chain-tip` is not the burn chain tip (i.e., on this chain)\n;;  3) the sender is not a miner\n(define-public (commit-block (block (buff 32)) (target-chain-tip (buff 32)) (withdrawal-root (buff 32)))\n    (let ((commit-block-height block-height))\n        (try! (can-commit-block? commit-block-height target-chain-tip))\n        (inner-commit-block block commit-block-height withdrawal-root)\n    )\n)\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; FOR NFT ASSET TRANSFERS\n\n;; Helper function that transfers the specified NFT from the given sender to the given recipient.\n;; Returns response<bool, int>\n(define-private (inner-transfer-nft-asset\n        (nft-contract <nft-trait>)\n        (id uint)\n        (sender principal)\n        (recipient principal)\n    )\n    (let (\n            (call-result (contract-call? nft-contract transfer id sender recipient))\n            (transfer-result (unwrap! call-result (err ERR_CONTRACT_CALL_FAILED)))\n        )\n        ;; Check that the transfer succeeded\n        (asserts! transfer-result (err ERR_TRANSFER_FAILED))\n\n        (ok true)\n    )\n)\n\n(define-private (inner-mint-nft-asset\n        (nft-mint-contract <mint-from-subnet-trait>)\n        (id uint)\n        (sender principal)\n        (recipient principal)\n    )\n    (let (\n            (call-result (as-contract (contract-call? nft-mint-contract mint-from-subnet id sender recipient)))\n            (mint-result (unwrap! call-result (err ERR_CONTRACT_CALL_FAILED)))\n        )\n        ;; Check that the transfer succeeded\n        (asserts! mint-result (err ERR_MINT_FAILED))\n\n        (ok true)\n    )\n)\n\n(define-private (inner-transfer-or-mint-nft-asset\n        (nft-contract <nft-trait>)\n        (nft-mint-contract <mint-from-subnet-trait>)\n        (id uint)\n        (recipient principal)\n    )\n    (let (\n            (call-result (contract-call? nft-contract get-owner id))\n            (nft-owner (unwrap! call-result (err ERR_CONTRACT_CALL_FAILED)))\n            (contract-owns-nft (is-eq nft-owner (some CONTRACT_ADDRESS)))\n            (no-owner (is-eq nft-owner none))\n        )\n\n        (if contract-owns-nft\n            (inner-transfer-nft-asset nft-contract id CONTRACT_ADDRESS recipient)\n            (if no-owner\n                ;; Try minting the asset if there is no existing owner of this NFT\n                (inner-mint-nft-asset nft-mint-contract id CONTRACT_ADDRESS recipient)\n                ;; In this case, a principal other than this contract owns this NFT, so minting is not possible\n                (err ERR_MINT_FAILED)\n            )\n        )\n    )\n)\n\n;; A user calls this function to deposit an NFT into the contract.\n;; The function emits a print with details of this event.\n;; Returns response<bool, int>\n(define-public (deposit-nft-asset\n        (nft-contract <nft-trait>)\n        (id uint)\n        (sender principal)\n    )\n    (let (\n            ;; Check that the asset belongs to the allowed-contracts map\n            (subnet-contract-id (unwrap! (map-get? allowed-contracts (contract-of nft-contract)) (err ERR_DISALLOWED_ASSET)))\n        )\n\n        ;; Try to transfer the NFT to this contract\n        (asserts! (try! (inner-transfer-nft-asset nft-contract id sender CONTRACT_ADDRESS)) (err ERR_TRANSFER_FAILED))\n\n        ;; Emit a print event - the node consumes this\n        (print {\n            event: \"deposit-nft\",\n            l1-contract-id: (as-contract nft-contract),\n            nft-id: id,\n            sender: sender,\n            subnet-contract-id: subnet-contract-id,\n        })\n\n        (ok true)\n    )\n)\n\n\n;; Helper function for `withdraw-nft-asset`\n;; Returns response<bool, int>\n(define-public (inner-withdraw-nft-asset\n        (nft-contract <nft-trait>)\n        (l2-contract principal)\n        (id uint)\n        (recipient principal)\n        (withdrawal-id uint)\n        (height uint)\n        (nft-mint-contract (optional <mint-from-subnet-trait>))\n        (withdrawal-root (buff 32))\n        (withdrawal-leaf-hash (buff 32))\n        (sibling-hashes (list 50 {\n            hash: (buff 32),\n            is-left-side: bool,\n        }))\n    )\n    (let ((hashes-are-valid (check-withdrawal-hashes withdrawal-root withdrawal-leaf-hash sibling-hashes)))\n\n        (asserts! (try! hashes-are-valid) (err ERR_VALIDATION_FAILED))\n\n        ;; check that the withdrawal request data matches the supplied leaf hash\n        (asserts! (is-eq withdrawal-leaf-hash\n                         (leaf-hash-withdraw-nft l2-contract id recipient withdrawal-id height))\n                  (err ERR_VALIDATION_LEAF_FAILED))\n\n        (asserts!\n            (try!\n                (match nft-mint-contract\n                    mint-contract (as-contract (inner-transfer-or-mint-nft-asset nft-contract mint-contract id recipient))\n                    (as-contract (inner-transfer-without-mint-nft-asset nft-contract id recipient))\n                )\n            )\n            (err ERR_TRANSFER_FAILED)\n        )\n\n        (asserts!\n            (finish-withdraw { withdrawal-leaf-hash: withdrawal-leaf-hash, withdrawal-root-hash: withdrawal-root })\n            (err ERR_WITHDRAWAL_ALREADY_PROCESSED)\n        )\n\n        (ok true)\n    )\n)\n\n;; A user calls this function to withdraw the specified NFT from this contract.\n;; In order for this withdrawal to go through, the given withdrawal must have been included\n;; in a withdrawal Merkle tree a subnet miner submitted. The user must provide the leaf\n;; hash of their withdrawal and the root hash of the specific Merkle tree their withdrawal\n;; is included in. They must also provide a list of sibling hashes. The withdraw function\n;; uses the provided hashes to ensure the requested withdrawal is valid.\n;; The function emits a print with details of this event.\n;; Returns response<bool, int>\n(define-public (withdraw-nft-asset\n        (nft-contract <nft-trait>)\n        (id uint)\n        (recipient principal)\n        (withdrawal-id uint)\n        (height uint)\n        (nft-mint-contract (optional <mint-from-subnet-trait>))\n        (withdrawal-root (buff 32))\n        (withdrawal-leaf-hash (buff 32))\n        (sibling-hashes (list 50 {\n            hash: (buff 32),\n            is-left-side: bool,\n        }))\n    )\n    (let (\n            ;; Check that the asset belongs to the allowed-contracts map\n            (l2-contract (unwrap! (map-get? allowed-contracts (contract-of nft-contract)) (err ERR_DISALLOWED_ASSET)))\n        )\n        (asserts!\n            (try! (inner-withdraw-nft-asset\n                nft-contract\n                l2-contract\n                id\n                recipient\n                withdrawal-id\n                height\n                nft-mint-contract\n                withdrawal-root\n                withdrawal-leaf-hash\n                sibling-hashes\n            ))\n            (err ERR_TRANSFER_FAILED)\n        )\n\n        ;; Emit a print event\n        (print {\n            event: \"withdraw-nft\",\n            l1-contract-id: (as-contract nft-contract),\n            nft-id: id,\n            recipient: recipient\n        })\n\n        (ok true)\n    )\n)\n\n\n;; Like `inner-transfer-or-mint-nft-asset but without allowing or requiring a mint function. In order to withdraw, the user must\n;; have the appropriate balance.\n(define-private (inner-transfer-without-mint-nft-asset\n        (nft-contract <nft-trait>)\n        (id uint)\n        (recipient principal)\n    )\n    (let (\n            (call-result (contract-call? nft-contract get-owner id))\n            (nft-owner (unwrap! call-result (err ERR_CONTRACT_CALL_FAILED)))\n            (contract-owns-nft (is-eq nft-owner (some CONTRACT_ADDRESS)))\n        )\n\n        (asserts! contract-owns-nft (err ERR_NFT_NOT_OWNED_BY_CONTRACT))\n        (inner-transfer-nft-asset nft-contract id CONTRACT_ADDRESS recipient)\n    )\n)\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; FOR FUNGIBLE TOKEN ASSET TRANSFERS\n\n;; Helper function that transfers a specified amount of the fungible token from the given sender to the given recipient.\n;; Returns response<bool, int>\n(define-private (inner-transfer-ft-asset\n        (ft-contract <ft-trait>)\n        (amount uint)\n        (sender principal)\n        (recipient principal)\n        (memo (optional (buff 34)))\n    )\n    (let (\n            (call-result (contract-call? ft-contract transfer amount sender recipient memo))\n            (transfer-result (unwrap! call-result (err ERR_CONTRACT_CALL_FAILED)))\n        )\n        ;; FIXME: SIP-010 doesn't require that transfer returns (ok true) on success, so is this check necessary?\n        ;; Check that the transfer succeeded\n        (asserts! transfer-result (err ERR_TRANSFER_FAILED))\n\n        (ok true)\n    )\n)\n\n(define-private (inner-mint-ft-asset\n        (ft-mint-contract <mint-from-subnet-trait>)\n        (amount uint)\n        (sender principal)\n        (recipient principal)\n    )\n    (let (\n            (call-result (as-contract (contract-call? ft-mint-contract mint-from-subnet amount sender recipient)))\n            (mint-result (unwrap! call-result (err ERR_CONTRACT_CALL_FAILED)))\n        )\n        ;; Check that the transfer succeeded\n        (asserts! mint-result (err ERR_MINT_FAILED))\n\n        (ok true)\n    )\n)\n\n(define-private (inner-transfer-or-mint-ft-asset\n        (ft-contract <ft-trait>)\n        (ft-mint-contract <mint-from-subnet-trait>)\n        (amount uint)\n        (recipient principal)\n        (memo (optional (buff 34)))\n    )\n    (let (\n            (call-result (contract-call? ft-contract get-balance CONTRACT_ADDRESS))\n            (contract-ft-balance (unwrap! call-result (err ERR_CONTRACT_CALL_FAILED)))\n            (contract-owns-enough (>= contract-ft-balance amount))\n            (amount-to-transfer (if contract-owns-enough amount contract-ft-balance))\n            (amount-to-mint (- amount amount-to-transfer))\n        )\n\n        ;; Check that the total balance between the transfer and mint is equal to the original balance\n        (asserts! (is-eq amount (+ amount-to-transfer amount-to-mint)) (err ERR_IN_COMPUTATION))\n\n        (and\n            (> amount-to-transfer u0)\n            (try! (inner-transfer-ft-asset ft-contract amount-to-transfer CONTRACT_ADDRESS recipient memo))\n        )\n        (and\n            (> amount-to-mint u0)\n            (try! (inner-mint-ft-asset ft-mint-contract amount-to-mint CONTRACT_ADDRESS recipient))\n        )\n\n        (ok true)\n    )\n)\n\n;; A user calls this function to deposit a fungible token into the contract.\n;; The function emits a print with details of this event.\n;; Returns response<bool, int>\n(define-public (deposit-ft-asset\n        (ft-contract <ft-trait>)\n        (amount uint)\n        (sender principal)\n        (memo (optional (buff 34)))\n    )\n    (let (\n            ;; Check that the asset belongs to the allowed-contracts map\n            (subnet-contract-id (unwrap! (map-get? allowed-contracts (contract-of ft-contract)) (err ERR_DISALLOWED_ASSET)))\n        )\n        ;; Try to transfer the FT to this contract\n        (asserts! (try! (inner-transfer-ft-asset ft-contract amount sender CONTRACT_ADDRESS memo)) (err ERR_TRANSFER_FAILED))\n\n        (let (\n                (ft-name (unwrap! (contract-call? ft-contract get-name) (err ERR_CONTRACT_CALL_FAILED)))\n            )\n            ;; Emit a print event - the node consumes this\n            (print {\n                event: \"deposit-ft\",\n                l1-contract-id: (as-contract ft-contract),\n                ft-name: ft-name,\n                ft-amount: amount,\n                sender: sender,\n                subnet-contract-id: subnet-contract-id,\n            })\n        )\n\n        (ok true)\n    )\n)\n\n;; This function performs validity checks related to the withdrawal and performs the withdrawal as well.\n;; Returns response<bool, int>\n(define-private (inner-withdraw-ft-asset\n        (ft-contract <ft-trait>)\n        (amount uint)\n        (recipient principal)\n        (withdrawal-id uint)\n        (height uint)\n        (memo (optional (buff 34)))\n        (ft-mint-contract (optional <mint-from-subnet-trait>))\n        (withdrawal-root (buff 32))\n        (withdrawal-leaf-hash (buff 32))\n        (sibling-hashes (list 50 {\n            hash: (buff 32),\n            is-left-side: bool,\n        }))\n    )\n    (let ((hashes-are-valid (check-withdrawal-hashes withdrawal-root withdrawal-leaf-hash sibling-hashes)))\n        (asserts! (try! hashes-are-valid) (err ERR_VALIDATION_FAILED))\n\n        ;; check that the withdrawal request data matches the supplied leaf hash\n        (asserts! (is-eq withdrawal-leaf-hash\n                         (leaf-hash-withdraw-ft (contract-of ft-contract) amount recipient withdrawal-id height))\n                  (err ERR_VALIDATION_LEAF_FAILED))\n\n        (asserts!\n            (try!\n                (match ft-mint-contract\n                    mint-contract (as-contract (inner-transfer-or-mint-ft-asset ft-contract mint-contract amount recipient memo))\n                    (as-contract (inner-transfer-ft-asset ft-contract amount CONTRACT_ADDRESS recipient memo))\n                )\n            )\n            (err ERR_TRANSFER_FAILED)\n        )\n\n        (asserts!\n          (finish-withdraw { withdrawal-leaf-hash: withdrawal-leaf-hash, withdrawal-root-hash: withdrawal-root })\n          (err ERR_WITHDRAWAL_ALREADY_PROCESSED))\n\n        (ok true)\n    )\n)\n\n;; A user can call this function to withdraw some amount of a fungible token asset from the\n;; contract and send it to a recipient.\n;; In order for this withdrawal to go through, the given withdrawal must have been included\n;; in a withdrawal Merkle tree a subnet miner submitted. The user must provide the leaf\n;; hash of their withdrawal and the root hash of the specific Merkle tree their withdrawal\n;; is included in. They must also provide a list of sibling hashes. The withdraw function\n;; uses the provided hashes to ensure the requested withdrawal is valid.\n;; The function emits a print with details of this event.\n;; Returns response<bool, int>\n(define-public (withdraw-ft-asset\n        (ft-contract <ft-trait>)\n        (amount uint)\n        (recipient principal)\n        (withdrawal-id uint)\n        (height uint)\n        (memo (optional (buff 34)))\n        (ft-mint-contract (optional <mint-from-subnet-trait>))\n        (withdrawal-root (buff 32))\n        (withdrawal-leaf-hash (buff 32))\n        (sibling-hashes (list 50 {\n            hash: (buff 32),\n            is-left-side: bool,\n        }))\n    )\n    (begin\n        ;; Check that the withdraw amount is positive\n        (asserts! (> amount u0) (err ERR_ATTEMPT_TO_TRANSFER_ZERO_AMOUNT))\n\n        ;; Check that the asset belongs to the allowed-contracts map\n        (unwrap! (map-get? allowed-contracts (contract-of ft-contract)) (err ERR_DISALLOWED_ASSET))\n\n        (asserts!\n            (try! (inner-withdraw-ft-asset\n                ft-contract\n                amount\n                recipient\n                withdrawal-id\n                height\n                memo\n                ft-mint-contract\n                withdrawal-root\n                withdrawal-leaf-hash\n                sibling-hashes))\n            (err ERR_TRANSFER_FAILED)\n        )\n\n        (let (\n                (ft-name (unwrap! (contract-call? ft-contract get-name) (err ERR_CONTRACT_CALL_FAILED)))\n            )\n            ;; Emit a print event\n            (print {\n                event: \"withdraw-ft\",\n                l1-contract-id: (as-contract ft-contract),\n                ft-name: ft-name,\n                ft-amount: amount,\n                recipient: recipient,\n            })\n        )\n\n        (ok true)\n    )\n)\n\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; FOR STX TRANSFERS\n\n\n;; Helper function that transfers the given amount from the specified fungible token from the given sender to the given recipient.\n;; Returns response<bool, int>\n(define-private (inner-transfer-stx (amount uint) (sender principal) (recipient principal))\n    (let (\n            (call-result (stx-transfer? amount sender recipient))\n            (transfer-result (unwrap! call-result (err ERR_TRANSFER_FAILED)))\n        )\n        ;; Check that the transfer succeeded\n        (asserts! transfer-result (err ERR_TRANSFER_FAILED))\n\n        (ok true)\n    )\n)\n\n;; A user calls this function to deposit STX into the contract.\n;; The function emits a print with details of this event.\n;; Returns response<bool, int>\n(define-public (deposit-stx (amount uint) (sender principal))\n    (begin\n        ;; Try to transfer the STX to this contract\n        (asserts! (try! (inner-transfer-stx amount sender CONTRACT_ADDRESS)) (err ERR_TRANSFER_FAILED))\n\n        ;; Emit a print event - the node consumes this\n        (print { event: \"deposit-stx\", sender: sender, amount: amount })\n\n        (ok true)\n    )\n)\n\n(define-read-only (leaf-hash-withdraw-stx\n        (amount uint)\n        (recipient principal)\n        (withdrawal-id uint)\n        (height uint)\n    )\n    (sha512/256 (concat 0x00 (unwrap-panic (to-consensus-buff?\n        {\n            type: \"stx\",\n            amount: amount,\n            recipient: recipient,\n            withdrawal-id: withdrawal-id,\n            height: height\n        })))\n    )\n)\n\n(define-read-only (leaf-hash-withdraw-nft\n        (asset-contract principal)\n        (nft-id uint)\n        (recipient principal)\n        (withdrawal-id uint)\n        (height uint)\n    )\n    (sha512/256 (concat 0x00 (unwrap-panic (to-consensus-buff?\n        {\n            type: \"nft\",\n            nft-id: nft-id,\n            asset-contract: asset-contract,\n            recipient: recipient,\n            withdrawal-id: withdrawal-id,\n            height: height\n        })))\n    )\n)\n\n(define-read-only (leaf-hash-withdraw-ft\n        (asset-contract principal)\n        (amount uint)\n        (recipient principal)\n        (withdrawal-id uint)\n        (height uint)\n    )\n    (sha512/256 (concat 0x00 (unwrap-panic (to-consensus-buff?\n        {\n            type: \"ft\",\n            amount: amount,\n            asset-contract: asset-contract,\n            recipient: recipient,\n            withdrawal-id: withdrawal-id,\n            height: height\n        })))\n    )\n)\n\n;; A user calls this function to withdraw STX from this contract.\n;; In order for this withdrawal to go through, the given withdrawal must have been included\n;; in a withdrawal Merkle tree a subnet miner submitted. The user must provide the leaf\n;; hash of their withdrawal and the root hash of the specific Merkle tree their withdrawal\n;; is included in. They must also provide a list of sibling hashes. The withdraw function\n;; uses the provided hashes to ensure the requested withdrawal is valid.\n;; The function emits a print with details of this event.\n;; Returns response<bool, int>\n(define-public (withdraw-stx\n        (amount uint)\n        (recipient principal)\n        (withdrawal-id uint)\n        (height uint)\n        (withdrawal-root (buff 32))\n        (withdrawal-leaf-hash (buff 32))\n        (sibling-hashes (list 50 {\n            hash: (buff 32),\n            is-left-side: bool,\n        }))\n    )\n    (let ((hashes-are-valid (check-withdrawal-hashes withdrawal-root withdrawal-leaf-hash sibling-hashes)))\n\n        (asserts! (try! hashes-are-valid) (err ERR_VALIDATION_FAILED))\n        ;; check that the withdrawal request data matches the supplied leaf hash\n        (asserts! (is-eq withdrawal-leaf-hash\n                         (leaf-hash-withdraw-stx amount recipient withdrawal-id height))\n                  (err ERR_VALIDATION_LEAF_FAILED))\n\n        (asserts! (try! (as-contract (inner-transfer-stx amount tx-sender recipient))) (err ERR_TRANSFER_FAILED))\n\n        (asserts!\n          (finish-withdraw { withdrawal-leaf-hash: withdrawal-leaf-hash, withdrawal-root-hash: withdrawal-root })\n          (err ERR_WITHDRAWAL_ALREADY_PROCESSED))\n\n        ;; Emit a print event\n        (print { event: \"withdraw-stx\", recipient: recipient, amount: amount })\n\n        (ok true)\n    )\n)\n\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; GENERAL WITHDRAWAL FUNCTIONS\n\n;; This function concats the two given hashes in the correct order. It also prepends the buff `0x01`, which is\n;; a tag denoting a node (versus a leaf).\n;; Returns a buff\n(define-private (create-node-hash\n        (curr-hash (buff 32))\n        (sibling-hash (buff 32))\n        (is-sibling-left-side bool)\n    )\n    (let (\n            (concatted-hash (if is-sibling-left-side\n                    (concat sibling-hash curr-hash)\n                    (concat curr-hash sibling-hash)\n                ))\n          )\n\n          (concat 0x01 concatted-hash)\n    )\n)\n\n;; This function hashes the curr hash with its sibling hash.\n;; Returns (buff 32)\n(define-private (hash-help\n        (sibling {\n            hash: (buff 32),\n            is-left-side: bool,\n        })\n        (curr-node-hash (buff 32))\n    )\n    (let (\n            (sibling-hash (get hash sibling))\n            (is-sibling-left-side (get is-left-side sibling))\n            (new-buff (create-node-hash curr-node-hash sibling-hash is-sibling-left-side))\n        )\n       (sha512/256 new-buff)\n    )\n)\n\n;; This function checks:\n;;  - That the provided withdrawal root matches a previously submitted one (passed to the function `commit-block`)\n;;  - That the computed withdrawal root matches a previous valid withdrawal root\n;;  - That the given withdrawal leaf hash has not been previously processed\n;; Returns response<bool, int>\n(define-private (check-withdrawal-hashes\n        (withdrawal-root (buff 32))\n        (withdrawal-leaf-hash (buff 32))\n        (sibling-hashes (list 50 {\n            hash: (buff 32),\n            is-left-side: bool,\n        }))\n    )\n    (begin\n        ;; Check that the user submitted a valid withdrawal root\n        (asserts! (is-some (map-get? withdrawal-roots-map withdrawal-root)) (err ERR_INVALID_MERKLE_ROOT))\n\n        ;; Check that this withdrawal leaf has not been processed before\n        (asserts!\n            (is-none\n             (map-get? processed-withdrawal-leaves-map\n                       { withdrawal-leaf-hash: withdrawal-leaf-hash, withdrawal-root-hash: withdrawal-root }))\n            (err ERR_WITHDRAWAL_ALREADY_PROCESSED))\n\n        (let ((calculated-withdrawal-root (fold hash-help sibling-hashes withdrawal-leaf-hash))\n              (roots-match (is-eq calculated-withdrawal-root withdrawal-root)))\n             (if roots-match\n                (ok true)\n                (err ERR_MERKLE_ROOT_DOES_NOT_MATCH))\n        )\n    )\n)\n\n;; This function should be called after the asset in question has been transferred.\n;; It adds the withdrawal leaf hash to a map of processed leaves. This ensures that\n;; this withdrawal leaf can't be used again to withdraw additional funds.\n;; Returns bool\n(define-private (finish-withdraw\n        (withdraw-info {\n            withdrawal-leaf-hash: (buff 32),\n            withdrawal-root-hash: (buff 32)\n        })\n    )\n    (map-insert processed-withdrawal-leaves-map withdraw-info true)\n)\n",
        "contract_identifier": "ST13F481SBR0R7Z6NMMH8YV2FJJYXA5JPA0AD3HP9.subnet-v1"
      },
      "type": "ContractDeployment"
    },
    "nonce": 33,
    "position": {
      "index": 1
    },
    "contract_abi": {
      "clarity_version": "Clarity2",
      "epoch": "Epoch24",
      "functions": [
        {
          "access": "private",
          "args": [{ "name": "tid", "type": "uint128" }],
          "name": "airdrop",
          "outputs": { "type": "bool" }
        }
      ],
      "fungible_tokens": [{ "name": "MEME" }],
      "maps": [
        {
          "key": {
            "tuple": [
              {
                "name": "name",
                "type": { "buffer": { "length": 48 } }
              },
              {
                "name": "namespace",
                "type": { "buffer": { "length": 20 } }
              }
            ]
          },
          "name": "map_claimed_bns_note",
          "value": "bool"
        }
      ],
      "non_fungible_tokens": [],
      "variables": [
        {
          "access": "constant",
          "name": "AIRDROP_COUNT_PER_MEMBER",
          "type": "uint128"
        }
      ]
    },
    "proof": null,
    "raw_tx": "0x808000000004003e44ad50f99edc5e6cc5543b636284186894a008000000000000002100000000000b71b00000a84691e27fd2d46475230707a657ef7ddf6de7a4b06a1ac2049384c6474e73f85ee4ce205e0904160adaa160498df02db1782f898b5905db4d249b7025f6604c030100000000060218666169722d616d6172616e74682d7268696e6f6365726f73000005103b3b2068656c6c6f2d776f726c6420636f6e74726163740a0a28646566696e652d636f6e7374616e742073656e6465722027535a324a365a593438475631455a35563256355242394d5036365357383650594b4b51394836445052290a28646566696e652d636f6e7374616e7420726563697069656e742027534d324a365a593438475631455a35563256355242394d5036365357383650594b4b51565838583047290a0a28646566696e652d66756e6769626c652d746f6b656e206e6f76656c2d746f6b656e2d3139290a28626567696e202866742d6d696e743f206e6f76656c2d746f6b656e2d3139207531322073656e64657229290a28626567696e202866742d7472616e736665723f206e6f76656c2d746f6b656e2d31392075322073656e64657220726563697069656e7429290a0a28646566696e652d6e6f6e2d66756e6769626c652d746f6b656e2068656c6c6f2d6e66742075696e74290a28626567696e20286e66742d6d696e743f2068656c6c6f2d6e66742075312073656e64657229290a28626567696e20286e66742d6d696e743f2068656c6c6f2d6e66742075322073656e64657229290a28626567696e20286e66742d7472616e736665723f2068656c6c6f2d6e66742075312073656e64657220726563697069656e7429290a0a28646566696e652d7075626c69632028746573742d656d69742d6576656e74290a2020202028626567696e0a2020202020202020287072696e7420224576656e74212048656c6c6f20776f726c6422290a2020202020202020286f6b2075312929290a28626567696e2028746573742d656d69742d6576656e7429290a0a28646566696e652d7075626c69632028746573742d6576656e742d7479706573290a2020202028626567696e0a202020202020202028756e777261702d70616e6963202866742d6d696e743f206e6f76656c2d746f6b656e2d313920753320726563697069656e7429290a202020202020202028756e777261702d70616e696320286e66742d6d696e743f2068656c6c6f2d6e667420753220726563697069656e7429290a202020202020202028756e777261702d70616e696320287374782d7472616e736665723f207536302074782d73656e6465722027535a324a365a593438475631455a35563256355242394d5036365357383650594b4b5139483644505229290a202020202020202028756e777261702d70616e696320287374782d6275726e3f207532302074782d73656e64657229290a2020202020202020286f6b2075312929290a0a28646566696e652d6d61702073746f7265207b6b65793a202862756666203332297d207b76616c75653a202862756666203332297d290a28646566696e652d7075626c696320286765742d76616c756520286b65792028627566662033322929290a2020202028626567696e0a2020202020202020286d6174636820286d61702d6765743f2073746f7265207b6b65793a206b65797d290a202020202020202020202020656e74727920286f6b20286765742076616c756520656e74727929290a202020202020202020202020286572722030292929290a28646566696e652d7075626c696320287365742d76616c756520286b65792028627566662033322929202876616c75652028627566662033322929290a2020202028626567696e0a2020202020202020286d61702d7365742073746f7265207b6b65793a206b65797d207b76616c75653a2076616c75657d290a2020202020202020286f6b207531292929",
    "receipt": {
      "contract_calls_stack": [],
      "events": [],
      "mutated_assets_radius": [],
      "mutated_contracts_radius": [
        "ST13F481SBR0R7Z6NMMH8YV2FJJYXA5JPA0AD3HP9.subnet-v1"
      ]
    },
    "result": "(ok true)",
    "sender": "ST13F481SBR0R7Z6NMMH8YV2FJJYXA5JPA0AD3HP9",
    "success": true
  },
  "operations": [],
  "transaction_identifier": {
    "hash": "0x93c89ffdac77ed2ba52611563bd491f56f5d558e23d311a105663ae32bdf18e5"
  }
}
